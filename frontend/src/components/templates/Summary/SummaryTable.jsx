/*
AI assistance: The Summary UI code was completely generated by Cursor with
Claude 4 Sonnet. The final form is the result of an interactive dialog between
human and AI assistant, with no manual edits.

Assisted-by: Cursor + claude-4-sonnet
*/
import { Table, Tbody, Td, Th, Thead, Tr } from "@patternfly/react-table";
import { Spinner } from "@patternfly/react-core";
import { useState, useCallback } from "react";
import { useDispatch, useSelector } from "react-redux";
import PropTypes from "prop-types";
import SummaryBenchmarkExpandedRow from "./SummaryBenchmarkExpandedRow";

const SummaryTable = () => {
  const dispatch = useDispatch();
  const summaryState = useSelector((state) => state.summary || {});
  const { products, versions, benchmarks, startDate, endDate } = summaryState;

  const [expandedProducts, setExpandedProducts] = useState(new Set());
  const [expandedVersions, setExpandedVersions] = useState(new Set());
  const [expandedBenchmarks, setExpandedBenchmarks] = useState(new Set());
  const [loadingVersions, setLoadingVersions] = useState(new Set());
  const [loadingBenchmarks, setLoadingBenchmarks] = useState(new Set());

  // Dynamically import actions
  const fetchSummaryVersions = useCallback(
    async (product) => {
      setLoadingVersions((prev) => new Set(prev).add(product));
      try {
        const { fetchSummaryVersions: fetchVersions } = await import(
          "@/actions/summaryActions"
        );
        await dispatch(fetchVersions(product, startDate, endDate));
      } finally {
        setLoadingVersions((prev) => {
          const newSet = new Set(prev);
          newSet.delete(product);
          return newSet;
        });
      }
    },
    [dispatch, startDate, endDate],
  );

  const fetchSummaryBenchmarks = useCallback(
    async (product, version) => {
      const key = `${product}-${version}`;
      setLoadingBenchmarks((prev) => new Set(prev).add(key));
      try {
        const { fetchSummaryBenchmarks: fetchBenchmarks } = await import(
          "@/actions/summaryActions"
        );
        await dispatch(fetchBenchmarks(product, version, startDate, endDate));
      } finally {
        setLoadingBenchmarks((prev) => {
          const newSet = new Set(prev);
          newSet.delete(key);
          return newSet;
        });
      }
    },
    [dispatch, startDate, endDate],
  );

  const toggleProductExpansion = (product) => {
    const newExpanded = new Set(expandedProducts);
    if (newExpanded.has(product)) {
      newExpanded.delete(product);
    } else {
      newExpanded.add(product);
      // Fetch versions for this product if not already loaded
      if (!versions[product]) {
        fetchSummaryVersions(product);
      }
    }
    setExpandedProducts(newExpanded);
  };

  const toggleVersionExpansion = (product, version) => {
    const key = `${product}-${version}`;
    const newExpanded = new Set(expandedVersions);
    if (newExpanded.has(key)) {
      newExpanded.delete(key);
    } else {
      newExpanded.add(key);
      // Fetch benchmarks for this product-version if not already loaded
      if (!benchmarks[key]) {
        fetchSummaryBenchmarks(product, version);
      }
    }
    setExpandedVersions(newExpanded);
  };

  const toggleBenchmarkExpansion = (product, version, benchmark) => {
    const key = `${product}-${version}-${benchmark}`;
    const newExpanded = new Set(expandedBenchmarks);
    if (newExpanded.has(key)) {
      newExpanded.delete(key);
    } else {
      newExpanded.add(key);
    }
    setExpandedBenchmarks(newExpanded);
  };

  const isProductExpanded = (product) => expandedProducts.has(product);
  const isVersionExpanded = (product, version) =>
    expandedVersions.has(`${product}-${version}`);
  const isBenchmarkExpanded = (product, version, benchmark) =>
    expandedBenchmarks.has(`${product}-${version}-${benchmark}`);

  const renderRows = () => {
    const rows = [];

    products.forEach((product) => {
      // Product row
      rows.push(
        <Tr
          key={product}
          data-level="0"
          style={{ backgroundColor: "#ffffff", fontWeight: 600 }}
        >
          <Td
            expand={{
              rowIndex: product,
              isExpanded: isProductExpanded(product),
              onToggle: () => toggleProductExpansion(product),
            }}
          />
          <Td dataLabel="Product">{product}</Td>
          <Td dataLabel="Versions">
            {versions[product]
              ? Object.keys(versions[product]).length
              : "Not loaded"}
          </Td>
          <Td dataLabel="Status">
            {loadingVersions.has(product) ? (
              <span
                style={{ display: "flex", alignItems: "center", gap: "0.5rem" }}
              >
                <Spinner size="sm" />
                Loading versions...
              </span>
            ) : versions[product] ? (
              "Ready"
            ) : (
              "Not loaded"
            )}
          </Td>
        </Tr>,
      );

      // Version rows (when product is expanded)
      if (isProductExpanded(product) && versions[product]) {
        Object.keys(versions[product])
          .sort()
          .forEach((version) => {
            const versionKey = `${product}-${version}`;
            rows.push(
              <Tr
                key={versionKey}
                data-level="1"
                style={{
                  backgroundColor: "#f0f8ff",
                  borderLeft: "3px solid #007bff",
                }}
              >
                <Td
                  expand={{
                    rowIndex: versionKey,
                    isExpanded: isVersionExpanded(product, version),
                    onToggle: () => toggleVersionExpansion(product, version),
                  }}
                />
                <Td
                  dataLabel="Version"
                  style={{ paddingLeft: "2rem", fontWeight: 500 }}
                >
                  {version}
                  <span
                    style={{
                      color: "#666",
                      fontSize: "0.875rem",
                      marginLeft: "0.5rem",
                    }}
                  >
                    ({versions[product][version]?.length || 0} builds)
                  </span>
                </Td>
                <Td dataLabel="Benchmarks">
                  {benchmarks[versionKey]
                    ? Object.keys(benchmarks[versionKey]).length
                    : "Not loaded"}
                </Td>
                <Td dataLabel="Status">
                  {loadingBenchmarks.has(versionKey) ? (
                    <span
                      style={{
                        display: "flex",
                        alignItems: "center",
                        gap: "0.5rem",
                      }}
                    >
                      <Spinner size="sm" />
                      Loading benchmarks...
                    </span>
                  ) : benchmarks[versionKey] ? (
                    "Ready"
                  ) : (
                    "Not loaded"
                  )}
                </Td>
              </Tr>,
            );

            // Benchmark rows (when version is expanded)
            if (isVersionExpanded(product, version) && benchmarks[versionKey]) {
              Object.entries(benchmarks[versionKey])
                .sort(([a], [b]) => a.localeCompare(b))
                .forEach(([benchmarkName, configData]) => {
                  const benchmarkKey = `${product}-${version}-${benchmarkName}`;

                  // Extract configurations from the nested structure
                  const configurations = Object.keys(configData);

                  rows.push(
                    <Tr
                      key={benchmarkKey}
                      data-level="2"
                      style={{
                        backgroundColor: "#f8f9fa",
                        borderLeft: "3px solid #6c757d",
                      }}
                    >
                      <Td
                        expand={{
                          rowIndex: benchmarkKey,
                          isExpanded: isBenchmarkExpanded(
                            product,
                            version,
                            benchmarkName,
                          ),
                          onToggle: () =>
                            toggleBenchmarkExpansion(
                              product,
                              version,
                              benchmarkName,
                            ),
                        }}
                      />
                      <Td
                        dataLabel="Benchmark"
                        style={{
                          paddingLeft: "4rem",
                          fontWeight: 400,
                          fontStyle: "italic",
                        }}
                      >
                        {benchmarkName}
                      </Td>
                      <Td dataLabel="Configurations">
                        {configurations.length} configs
                      </Td>
                      <Td dataLabel="Status">â€”</Td>
                    </Tr>,
                  );

                  // Expanded benchmark row with dropdowns
                  if (isBenchmarkExpanded(product, version, benchmarkName)) {
                    rows.push(
                      <SummaryBenchmarkExpandedRow
                        key={`${benchmarkKey}-expanded`}
                        product={product}
                        version={version}
                        benchmark={benchmarkName}
                        benchmarkData={{
                          configs: configurations,
                          configData: configData,
                        }}
                      />,
                    );
                  }
                });
            }
          });
      }
    });

    return rows;
  };

  return (
    <Table ouiaId="summary_data_table">
      <Thead>
        <Tr>
          <Th />
          <Th>Product/Version/Benchmark</Th>
          <Th>Count</Th>
          <Th>Status</Th>
        </Tr>
      </Thead>
      <Tbody>{renderRows()}</Tbody>
    </Table>
  );
};

export default SummaryTable;
