/*
AI assistance: The Summary UI code was completely generated by Cursor with
Claude 4 Sonnet. The final form is the result of an interactive dialog between
human and AI assistant, with no manual edits.

Assisted-by: Cursor + claude-4-sonnet
*/
import {
  Card,
  CardBody,
  Grid,
  GridItem,
  Title,
  DescriptionList,
  DescriptionListTerm,
  DescriptionListDescription,
  DescriptionListGroup,
  Select,
  SelectList,
  SelectOption,
  MenuToggle,
  Spinner,
} from "@patternfly/react-core";
import { Td, Tr } from "@patternfly/react-table";
import { useState, useCallback } from "react";
import { useDispatch, useSelector } from "react-redux";
import PropTypes from "prop-types";
import PlotGraph from "@/components/atoms/PlotGraph";

// Readiness indicator component
const ReadinessIndicator = ({ status }) => {
  const getIndicatorStyle = (status) => {
    switch (status) {
      case "ready":
        return { backgroundColor: "#28a745", color: "white" };
      case "warning":
        return { backgroundColor: "#ffc107", color: "black" };
      case "not ready":
        return { backgroundColor: "#dc3545", color: "white" };
      default:
        return { backgroundColor: "#6c757d", color: "white" };
    }
  };

  if (!status) return null;

  return (
    <span
      className="readiness-indicator"
      style={{
        ...getIndicatorStyle(status),
        padding: "0.25rem 0.5rem",
        borderRadius: "4px",
        fontSize: "0.75rem",
        fontWeight: "600",
        textTransform: "uppercase",
        display: "inline-block",
        marginLeft: "0.5rem",
      }}
    >
      {status}
    </span>
  );
};

ReadinessIndicator.propTypes = {
  status: PropTypes.string,
};

const SummaryBenchmarkExpandedRow = ({
  product,
  version,
  benchmark,
  benchmarkData,
}) => {
  const dispatch = useDispatch();
  const summaryState = useSelector((state) => state.summary || {});
  const { summaryData, startDate, endDate } = summaryState;

  const [selectedConfig, setSelectedConfig] = useState(
    benchmarkData.configs?.sort()?.[0] || "",
  );
  const [selectedIteration, setSelectedIteration] = useState("");
  const [isConfigSelectOpen, setIsConfigSelectOpen] = useState(false);
  const [isIterationSelectOpen, setIsIterationSelectOpen] = useState(false);
  const [isLoadingData, setIsLoadingData] = useState(false);

  // Get available iterations for the selected configuration
  const getAvailableIterations = () => {
    if (!selectedConfig || !benchmarkData.configurationsObj?.[selectedConfig]) {
      return [];
    }
    // The benchmarks API returns iteration counts directly as keys in the config object
    // The iterations are NOT nested under an "iterations" key in this API
    const configObj = benchmarkData.configurationsObj[selectedConfig];
    // Return iteration keys directly from the config object
    return Object.keys(configObj);
  };

  const availableIterations = getAvailableIterations();

  // Set default iteration if not selected
  if (!selectedIteration && availableIterations.length > 0) {
    const sortedIterations = availableIterations.sort(
      (a, b) => Number(a) - Number(b),
    );
    setSelectedIteration(sortedIterations[0]);
  }

  // Get the summary data for this combination (include config and iteration for uniqueness)
  const dataKey = `${product}-${version}-${benchmark}-${selectedConfig}-${selectedIteration}`;
  const currentSummaryData = summaryData[dataKey];

  // Dynamically import actions
  const fetchSummaryData = useCallback(
    async (
      product,
      version,
      benchmark,
      config,
      iteration,
      startDate,
      endDate,
    ) => {
      setIsLoadingData(true);
      try {
        const { fetchSummaryData: fetchData } = await import(
          "@/actions/summaryActions"
        );
        await dispatch(
          fetchData(
            product,
            version,
            benchmark,
            config,
            iteration,
            startDate,
            endDate,
          ),
        );
      } finally {
        setIsLoadingData(false);
      }
    },
    [dispatch],
  );

  const formatStatValue = (value) => {
    if (value === null || value === undefined) return "N/A";
    if (typeof value === "number") return value.toLocaleString();
    return value;
  };

  const handleConfigSelect = (_event, value) => {
    setSelectedConfig(value);
    setIsConfigSelectOpen(false);
    // Reset iteration selection when config changes
    const configObj = benchmarkData.configurationsObj?.[value];
    // Iterations are directly in the config object, not nested under "iterations"
    const newIterations = configObj ? Object.keys(configObj) : [];
    if (newIterations.length > 0) {
      const sortedIterations = newIterations.sort(
        (a, b) => Number(a) - Number(b),
      );
      setSelectedIteration(sortedIterations[0]);
    } else {
      setSelectedIteration("");
    }
  };

  const handleIterationSelect = (_event, value) => {
    setSelectedIteration(value);
    setIsIterationSelectOpen(false);
  };

  // Fetch data when component mounts or selections change
  const handleFetchData = () => {
    if (selectedConfig && selectedIteration) {
      fetchSummaryData(
        product,
        version,
        benchmark,
        selectedConfig,
        selectedIteration,
        startDate,
        endDate,
      );
    }
  };

  const configToggle = (toggleRef) => (
    <MenuToggle
      ref={toggleRef}
      onClick={() => setIsConfigSelectOpen(!isConfigSelectOpen)}
      isExpanded={isConfigSelectOpen}
      style={{ width: "300px" }}
    >
      {selectedConfig ? `Config: ${selectedConfig}` : "Select Configuration"}
    </MenuToggle>
  );

  const iterationToggle = (toggleRef) => (
    <MenuToggle
      ref={toggleRef}
      onClick={() => setIsIterationSelectOpen(!isIterationSelectOpen)}
      isExpanded={isIterationSelectOpen}
      style={{ width: "200px" }}
    >
      {selectedIteration
        ? `Iterations: ${selectedIteration}`
        : "Select Iteration Count"}
    </MenuToggle>
  );

  // Extract data for the selected configuration and iteration
  const getSelectedData = () => {
    if (!currentSummaryData || !selectedConfig || !selectedIteration) {
      return null;
    }

    console.log(`Looking for data in currentSummaryData:`, currentSummaryData);
    console.log(
      `Selected config: ${selectedConfig}, iteration: ${selectedIteration}`,
    );

    // Navigate the new API response structure: product -> versions -> version -> benchmarks -> benchmark -> configurations -> config -> iterations -> iteration
    const productData = currentSummaryData[product];
    if (!productData) {
      console.log(`No data found for product: ${product}`);
      return null;
    }

    const versionsData = productData.versions;
    if (!versionsData) {
      console.log(`No versions data found in product data`);
      return null;
    }

    const versionData = versionsData[version];
    if (!versionData) {
      console.log(`No data found for version: ${version}`);
      return null;
    }

    const benchmarksData = versionData.benchmarks;
    if (!benchmarksData) {
      console.log(`No benchmarks data found for version: ${version}`);
      return null;
    }

    const benchmarkData = benchmarksData[benchmark];
    if (!benchmarkData) {
      console.log(`No data found for benchmark: ${benchmark}`);
      return null;
    }

    const configurationsData = benchmarkData.configurations;
    if (!configurationsData) {
      console.log(`No configurations data found for benchmark: ${benchmark}`);
      return null;
    }

    const configData = configurationsData[selectedConfig];
    if (!configData) {
      console.log(`No data found for config: ${selectedConfig}`);
      return null;
    }

    const iterationsData = configData.iterations;
    if (!iterationsData) {
      console.log(`No iterations data found for config: ${selectedConfig}`);
      return null;
    }

    const iterationData = iterationsData[selectedIteration];
    if (!iterationData) {
      console.log(`No data found for iteration: ${selectedIteration}`);
      return null;
    }

    console.log(`Found iteration data:`, iterationData);

    // Return both the iteration data and readiness information
    return {
      ...iterationData,
      configReadiness: configData.readiness,
      iterationReadiness: iterationData.readiness,
    };
  };

  const selectedData = getSelectedData();

  return (
    <Tr data-level="3">
      <Td />
      <Td colSpan={3} style={{ padding: "1rem 2rem" }}>
        <div className="summary-expanded-content">
          <Card>
            <CardBody>
              <Title
                headingLevel="h4"
                size="lg"
                style={{ marginBottom: "1rem" }}
              >
                {product} - {version} - {benchmark}
              </Title>

              {/* Configuration and Iteration Selectors */}
              <Grid
                hasGutter
                className="selector-grid"
                style={{ marginBottom: "1rem" }}
              >
                <GridItem span={4}>
                  <Title
                    headingLevel="h6"
                    size="sm"
                    style={{ marginBottom: "0.5rem" }}
                  >
                    Select Configuration:
                  </Title>
                  <Select
                    isOpen={isConfigSelectOpen}
                    selected={selectedConfig}
                    onSelect={handleConfigSelect}
                    onOpenChange={(isOpen) => setIsConfigSelectOpen(isOpen)}
                    toggle={configToggle}
                  >
                    <SelectList>
                      {benchmarkData.configs?.sort().map((config) => (
                        <SelectOption key={config} value={config}>
                          {config}
                        </SelectOption>
                      ))}
                    </SelectList>
                  </Select>
                </GridItem>

                {availableIterations.length > 1 && (
                  <GridItem span={4}>
                    <Title
                      headingLevel="h6"
                      size="sm"
                      style={{ marginBottom: "0.5rem" }}
                    >
                      Select Iteration Count:
                    </Title>
                    <Select
                      isOpen={isIterationSelectOpen}
                      selected={selectedIteration}
                      onSelect={handleIterationSelect}
                      onOpenChange={(isOpen) =>
                        setIsIterationSelectOpen(isOpen)
                      }
                      toggle={iterationToggle}
                    >
                      <SelectList>
                        {availableIterations
                          .sort((a, b) => Number(a) - Number(b))
                          .map((iteration) => {
                            // Get run count from the benchmarks API structure (just a count value)
                            const configObj = benchmarkData.configurationsObj?.[selectedConfig];
                            const count = configObj?.[iteration] || 0;
                            return (
                              <SelectOption key={iteration} value={iteration}>
                                {iteration} iterations ({count} runs)
                              </SelectOption>
                            );
                          })}
                      </SelectList>
                    </Select>
                  </GridItem>
                )}

                <GridItem span={4}>
                  <Title
                    headingLevel="h6"
                    size="sm"
                    style={{ marginBottom: "0.5rem" }}
                  >
                    &nbsp;
                  </Title>
                  <button
                    className="pf-c-button pf-m-primary"
                    onClick={handleFetchData}
                    disabled={
                      !selectedConfig || !selectedIteration || isLoadingData
                    }
                    style={{
                      display: "flex",
                      alignItems: "center",
                      gap: "0.5rem",
                    }}
                  >
                    {isLoadingData && <Spinner size="sm" />}
                    {isLoadingData ? "Loading..." : "Load Data"}
                  </button>
                </GridItem>
              </Grid>

              {selectedConfig && selectedIteration && (
                <div
                  style={{
                    marginBottom: "1rem",
                    padding: "0.75rem",
                    backgroundColor: "#f8f9fa",
                    borderRadius: "4px",
                    border: "1px solid #e9ecef",
                  }}
                >
                  <strong>Selected Configuration:</strong> {selectedConfig}
                  {selectedData?.configReadiness && (
                    <ReadinessIndicator status={selectedData.configReadiness} />
                  )}
                  <br />
                  <strong>Selected Iterations:</strong> {selectedIteration}{" "}
                  iterations (
                  {(() => {
                    const configObj = benchmarkData.configurationsObj?.[selectedConfig];
                    // The benchmarks API returns just a count value, not a full iteration object
                    return configObj?.[selectedIteration] || 0;
                  })()}{" "}
                  runs available)
                  {selectedData?.iterationReadiness && (
                    <ReadinessIndicator status={selectedData.iterationReadiness} />
                  )}
                </div>
              )}

              {selectedData && (
                <Grid hasGutter>
                  {/* Statistics Section */}
                  <GridItem span={6}>
                    <div className="stats-section">
                      <Title
                        headingLevel="h6"
                        size="sm"
                        style={{ marginBottom: "0.5rem" }}
                      >
                        Statistics ({selectedIteration} iterations)
                      </Title>
                      <DescriptionList isHorizontal>
                        <DescriptionListGroup>
                          <DescriptionListTerm>Minimum</DescriptionListTerm>
                          <DescriptionListDescription>
                            {formatStatValue(selectedData.stats?.min)}
                          </DescriptionListDescription>
                        </DescriptionListGroup>
                        <DescriptionListGroup>
                          <DescriptionListTerm>Maximum</DescriptionListTerm>
                          <DescriptionListDescription>
                            {formatStatValue(selectedData.stats?.max)}
                          </DescriptionListDescription>
                        </DescriptionListGroup>
                        <DescriptionListGroup>
                          <DescriptionListTerm>Average</DescriptionListTerm>
                          <DescriptionListDescription>
                            {formatStatValue(selectedData.stats?.avg)}
                          </DescriptionListDescription>
                        </DescriptionListGroup>
                        <DescriptionListGroup>
                          <DescriptionListTerm>
                            Std Deviation
                          </DescriptionListTerm>
                          <DescriptionListDescription>
                            {formatStatValue(selectedData.stats?.std_dev)}
                          </DescriptionListDescription>
                        </DescriptionListGroup>
                      </DescriptionList>

                      {/* Values List */}
                      {selectedData.values &&
                        selectedData.values.length > 0 && (
                          <>
                            <Title
                              headingLevel="h6"
                              size="sm"
                              style={{
                                marginTop: "1rem",
                                marginBottom: "0.5rem",
                              }}
                            >
                              Individual Values ({selectedData.values.length}{" "}
                              runs)
                            </Title>
                            <div className="values-list">
                              {selectedData.values.map((valueData, index) => (
                                <div
                                  key={`${valueData.uuid || "no-uuid"}-${index}`}
                                  className="value-item"
                                >
                                  <span className="value">
                                    {valueData.value?.toLocaleString()}
                                  </span>
                                  {valueData.timestamp && (
                                    <span className="timestamp">
                                      (
                                      {new Date(
                                        valueData.timestamp,
                                      ).toLocaleString()}
                                      )
                                    </span>
                                  )}
                                </div>
                              ))}
                            </div>
                          </>
                        )}
                    </div>
                  </GridItem>

                  {/* Chart Section */}
                  <GridItem span={6}>
                    <div className="chart-section">
                      <Title
                        headingLevel="h6"
                        size="sm"
                        style={{ marginBottom: "0.5rem" }}
                      >
                        Performance Chart
                      </Title>
                      {selectedData.graph &&
                        selectedData.graph.x &&
                        selectedData.graph.x.length > 0 ? (
                        <PlotGraph data={[selectedData.graph]} />
                      ) : (
                        <div className="no-data-placeholder">
                          No chart data available
                        </div>
                      )}
                    </div>
                  </GridItem>
                </Grid>
              )}

              {!selectedData &&
                selectedConfig &&
                selectedIteration &&
                !isLoadingData && (
                  <div style={{ textAlign: "center", padding: "2rem" }}>
                    <p>
                      Click "Load Data" to fetch metrics for the selected
                      configuration.
                    </p>
                  </div>
                )}

              {isLoadingData && !selectedData && (
                <div style={{ textAlign: "center", padding: "2rem" }}>
                  <div
                    style={{
                      display: "flex",
                      alignItems: "center",
                      justifyContent: "center",
                      gap: "0.5rem",
                    }}
                  >
                    <Spinner size="md" />
                    <p>Fetching metrics data...</p>
                  </div>
                </div>
              )}
            </CardBody>
          </Card>
        </div>
      </Td>
    </Tr>
  );
};

SummaryBenchmarkExpandedRow.propTypes = {
  product: PropTypes.string.isRequired,
  version: PropTypes.string.isRequired,
  benchmark: PropTypes.string.isRequired,
  benchmarkData: PropTypes.object.isRequired,
};

export default SummaryBenchmarkExpandedRow;
