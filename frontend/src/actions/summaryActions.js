/*
AI assistance: The Summary UI code was completely generated by Cursor with
Claude 4 Sonnet. The final form is the result of an interactive dialog between
human and AI assistant, with no manual edits.

Assisted-by: Cursor + claude-4-sonnet
*/
import * as API_ROUTES from "@/utils/apiConstants";
import * as TYPES from "./types.js";

import API from "@/utils/axiosInstance";
import { setLastUpdatedTime } from "./headerActions";

export const fetchSummaryProducts = () => async (dispatch) => {
  try {
    dispatch({ type: TYPES.SET_SUMMARY_LOADING });

    const response = await API.get(API_ROUTES.SUMMARY_PRODUCTS_API_V1);

    if (response.status === 200) {
      dispatch({
        type: TYPES.SET_SUMMARY_PRODUCTS,
        payload: response.data,
      });
    }

    dispatch(setLastUpdatedTime());
  } catch (error) {
    console.error(
      `ERROR (${error?.response?.status}): ${JSON.stringify(
        error?.response?.data,
      )}`,
    );
  }
  dispatch({ type: TYPES.SET_SUMMARY_COMPLETED });
};

export const fetchSummaryVersions =
  (product, startDate, endDate) => async (dispatch) => {
    try {
      // Don't set global loading for individual operations
      const params = { products: product };
      if (startDate) params.start_date = startDate;
      if (endDate) params.end_date = endDate;

      const response = await API.get(API_ROUTES.SUMMARY_VERSIONS_API_V1, {
        params,
      });

      if (response.status === 200) {
        dispatch({
          type: TYPES.SET_SUMMARY_VERSIONS,
          payload: { product, versions: response.data[product] || {} },
        });
      }
    } catch (error) {
      console.error(
        `ERROR (${error?.response?.status}): ${JSON.stringify(
          error?.response?.data,
        )}`,
      );
    }
  };

export const fetchSummaryBenchmarks =
  (product, version, startDate, endDate) => async (dispatch) => {
    try {
      // Don't set global loading for individual operations
      const params = { products: product, versions: version };
      if (startDate) params.start_date = startDate;
      if (endDate) params.end_date = endDate;
      const response = await API.get(API_ROUTES.SUMMARY_BENCHMARKS_API_V1, {
        params,
      });

      if (response.status === 200) {
        console.log(
          `Benchmarks API response for ${product}-${version}:`,
          response.data,
        );
        const benchmarksData = response.data[product]?.benchmarks || {};
        console.log(`Extracted benchmarks data:`, benchmarksData);
        dispatch({
          type: TYPES.SET_SUMMARY_BENCHMARKS,
          payload: { product, version, benchmarks: benchmarksData },
        });
      }
    } catch (error) {
      console.error(
        `ERROR (${error?.response?.status}): ${JSON.stringify(
          error?.response?.data,
        )}`,
      );
    }
  };

export const fetchSummaryData =
  (product, version, benchmark, config, iteration, startDate, endDate) =>
  async (dispatch) => {
    try {
      // Don't set global loading for individual operations
      const params = {
        products: product,
        versions: version,
        benchmarks: benchmark,
      };
      if (startDate) params.start_date = startDate;
      if (endDate) params.end_date = endDate;

      const response = await API.get(API_ROUTES.SUMMARY_API_V1, { params });

      if (response.status === 200) {
        console.log(
          `Summary data API response for ${product}-${version}-${benchmark}-${config}-${iteration}:`,
          response.data,
        );
        dispatch({
          type: TYPES.SET_SUMMARY_DATA,
          payload: {
            product,
            version,
            benchmark,
            config,
            iteration,
            data: response.data,
          },
        });
      }
    } catch (error) {
      console.error(
        `ERROR (${error?.response?.status}): ${JSON.stringify(
          error?.response?.data,
        )}`,
      );
    }
  };

export const setSummaryDateFilter = (startDate, endDate) => (dispatch) => {
  // Clear cached data when date filter changes
  dispatch({
    type: TYPES.CLEAR_SUMMARY_CACHED_DATA,
  });

  dispatch({
    type: TYPES.SET_SUMMARY_DATE_FILTER,
    payload: {
      startDate,
      endDate,
    },
  });
};
