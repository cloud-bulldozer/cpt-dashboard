from datetime import date, datetime
import json
from unittest.mock import AsyncMock

from fastapi.testclient import TestClient
import pandas as pd
import pytest

from app.main import app as fastapi_app

"""This is a test file for the CPT jobs endpoint.

Assisted-by: Cursor.

This file was generated by Cursor using the following prompt:

    write unit tests for cptJobs.py

The resulting tests were clear and well-structured, and aside from a few bugs
provided 99% code coverage ... but demonstrated several interesting
misunderstandings of the codebase:

1. All of the APIs return "JSON", but some serialize the JSON and return that
   as a JSON string, requiring `json.loads(result.json())` to get the actual
   JSON (dict). Cursor failed to recognize this, requiring some adjustment.
2. Cursor chose to mock the `fetch_data_limited` function, which limited the
   test coverage to 99%. While this isn't a big deal since it's a tiny
   passthrough function, I chose to write another test case to cover it.
3. Cursor misunderstood the "totalJobs" query parameter on the `jobs` endpoint,
   expecting the value to be returned as "total"; but that query parameter is
   used only when the offset is greater than 0. (I split this into two tests to
   cover both cases.)
4. Cursor misunderstood the use of the `fetch_data_limited` function to merge
   data from multiple products by "product" key, and supplied a hardcoded "ocp"
   product key which caused all the data to be overwritten and the expected
   total test to fail.

All of these issues were straightforward to fix.

Overall, Cursor showed remarkable understanding of the codebase and pytest test
methodologies: I'm impressed.
"""


@pytest.fixture
def client():
    """Create a Starlette test client."""
    yield TestClient(fastapi_app)


class TestGetDefaultDates:
    """Test the get_default_dates helper function."""

    def test_both_dates_provided(self, monkeypatch):
        from app.api.v1.endpoints.cpt.cptJobs import get_default_dates

        start = date(2023, 1, 1)
        end = date(2023, 1, 15)
        result_start, result_end = get_default_dates(start, end)

        assert result_start == start
        assert result_end == end

    def test_no_dates_provided(self, monkeypatch):
        from app.api.v1.endpoints.cpt.cptJobs import get_default_dates

        # Mock datetime.utcnow to return a fixed date
        fixed_date = datetime(2023, 1, 15, 10, 0, 0)

        class MockDatetime(datetime):
            @classmethod
            def utcnow(cls):
                return fixed_date

        monkeypatch.setattr("app.api.v1.endpoints.cpt.cptJobs.datetime", MockDatetime)

        result_start, result_end = get_default_dates(None, None)
        expected_start = date(2023, 1, 10)  # 5 days before
        expected_end = date(2023, 1, 15)

        assert result_start == expected_start
        assert result_end == expected_end

    def test_only_start_date_provided(self, monkeypatch):
        from app.api.v1.endpoints.cpt.cptJobs import get_default_dates

        fixed_date = datetime(2023, 1, 15, 10, 0, 0)

        class MockDatetime(datetime):
            @classmethod
            def utcnow(cls):
                return fixed_date

        monkeypatch.setattr("app.api.v1.endpoints.cpt.cptJobs.datetime", MockDatetime)

        start = date(2023, 1, 5)
        result_start, result_end = get_default_dates(start, None)

        assert result_start == start
        assert result_end == date(2023, 1, 15)

    def test_only_end_date_provided(self, monkeypatch):
        from app.api.v1.endpoints.cpt.cptJobs import get_default_dates

        fixed_date = datetime(2023, 1, 15, 10, 0, 0)

        class MockDatetime(datetime):
            @classmethod
            def utcnow(cls):
                return fixed_date

        monkeypatch.setattr("app.api.v1.endpoints.cpt.cptJobs.datetime", MockDatetime)

        end = date(2023, 1, 20)
        result_start, result_end = get_default_dates(None, end)

        assert result_start == date(2023, 1, 10)  # 5 days before today
        assert result_end == end


class TestFetchData:
    """Test the fetch_data helper function."""

    @pytest.mark.asyncio
    async def test_fetch_data_success_not_filter(self, monkeypatch):
        from app.api.v1.endpoints.cpt.cptJobs import fetch_data

        mock_response = {
            "data": pd.DataFrame({"col1": [1, 2], "col2": ["a", "b"]}),
            "total": 2,
            "summary": {"success": 2},
        }

        mock_mapper = AsyncMock(return_value=mock_response)
        monkeypatch.setattr(
            "app.api.v1.endpoints.cpt.cptJobs.products", {"ocp": mock_mapper}
        )

        result = await fetch_data(
            "ocp", date(2023, 1, 1), date(2023, 1, 15), 10, 0, "test_filter", False
        )

        assert not result["data"].empty
        assert result["total"] == 2
        assert result["summary"] == {"success": 2}
        mock_mapper.assert_called_once_with(
            date(2023, 1, 1), date(2023, 1, 15), 10, 0, "test_filter"
        )

    @pytest.mark.asyncio
    async def test_fetch_data_success_is_filter(self, monkeypatch):
        from app.api.v1.endpoints.cpt.cptJobs import fetch_data

        mock_response = {
            "filterData": [{"key": "test", "value": ["val1", "val2"]}],
            "total": 2,
            "summary": {"success": 2},
        }

        mock_filter = AsyncMock(return_value=mock_response)
        monkeypatch.setattr(
            "app.api.v1.endpoints.cpt.cptJobs.productsFilter", {"ocp": mock_filter}
        )

        result = await fetch_data(
            "ocp",
            date(2023, 1, 1),
            date(2023, 1, 15),
            filter="test_filter",
            is_filter=True,
        )

        assert result["data"] == [{"key": "test", "value": ["val1", "val2"]}]
        assert result["total"] == 2
        assert result["summary"] == {"success": 2}
        mock_filter.assert_called_once_with(
            date(2023, 1, 1), date(2023, 1, 15), "test_filter"
        )

    @pytest.mark.asyncio
    async def test_fetch_data_empty_response(self, monkeypatch):
        from app.api.v1.endpoints.cpt.cptJobs import fetch_data

        mock_mapper = AsyncMock(return_value=None)
        monkeypatch.setattr(
            "app.api.v1.endpoints.cpt.cptJobs.products", {"ocp": mock_mapper}
        )

        result = await fetch_data(
            "ocp", date(2023, 1, 1), date(2023, 1, 15), 10, 0, "test_filter", False
        )

        assert result["data"].empty
        assert result["total"] == 0

    @pytest.mark.asyncio
    async def test_fetch_data_limited(self, monkeypatch):
        from app.api.v1.endpoints.cpt.cptJobs import fetch_data_limited

        mock_mapper = AsyncMock(return_value=None)
        monkeypatch.setattr(
            "app.api.v1.endpoints.cpt.cptJobs.products", {"ocp": mock_mapper}
        )

        result = await fetch_data_limited(
            "ocp", date(2023, 1, 1), date(2023, 1, 15), 10, 0, "test_filter", False
        )

        assert result["data"].empty
        assert result["total"] == 0

    @pytest.mark.asyncio
    async def test_fetch_data_exception(self, monkeypatch):
        from app.api.v1.endpoints.cpt.cptJobs import fetch_data

        mock_mapper = AsyncMock(side_effect=Exception("Test error"))
        monkeypatch.setattr(
            "app.api.v1.endpoints.cpt.cptJobs.products", {"ocp": mock_mapper}
        )

        result = await fetch_data(
            "ocp", date(2023, 1, 1), date(2023, 1, 15), 10, 0, "test_filter", False
        )

        assert result["data"].empty
        assert result["total"] == 0


class TestJobsEndpoint:
    """Test the /api/v1/cpt/jobs endpoint."""

    def test_jobs_success_default_dates(self, client, monkeypatch):
        """Test successful jobs endpoint call with default dates."""
        # Mock datetime for default date calculation
        fixed_date = datetime(2023, 1, 15, 10, 0, 0)

        class MockDatetime(datetime):
            @classmethod
            def utcnow(cls):
                return fixed_date

        monkeypatch.setattr("app.api.v1.endpoints.cpt.cptJobs.datetime", MockDatetime)

        # Mock the product mappers
        mock_response = {
            "data": pd.DataFrame(
                {
                    "uuid": ["test-uuid"],
                    "testName": ["test"],
                    "jobStatus": ["SUCCESS"],
                    "product": ["ocp"],
                }
            ),
            "total": 1,
        }

        async def mock_fetch_data_limited(*args, **kwargs):
            return mock_response

        monkeypatch.setattr(
            "app.api.v1.endpoints.cpt.cptJobs.fetch_data_limited",
            mock_fetch_data_limited,
        )

        response = client.get("/api/v1/cpt/jobs")

        assert response.status_code == 200
        data = response.json()
        assert data["total"] == 5  # 5 products × 1 total each
        assert len(data["results"]) == 5  # 5 products × 1 result each
        assert data["startDate"] == "2023-01-10"
        assert data["endDate"] == "2023-01-15"

    def test_jobs_with_dates(self, client, monkeypatch):
        """Test jobs endpoint with specific dates."""
        mock_response = {
            "data": pd.DataFrame(
                {
                    "uuid": ["test-uuid"],
                    "testName": ["test"],
                    "jobStatus": ["SUCCESS"],
                    "product": ["ocp"],
                }
            ),
            "total": 1,
        }

        async def mock_fetch_data_limited(*args, **kwargs):
            return mock_response

        monkeypatch.setattr(
            "app.api.v1.endpoints.cpt.cptJobs.fetch_data_limited",
            mock_fetch_data_limited,
        )

        response = client.get(
            "/api/v1/cpt/jobs?start_date=2023-01-01&end_date=2023-01-15"
        )

        assert response.status_code == 200
        data = response.json()
        assert data["startDate"] == "2023-01-01"
        assert data["endDate"] == "2023-01-15"

    def test_jobs_invalid_date_range(self, client):
        """Test jobs endpoint with invalid date range."""
        response = client.get(
            "/api/v1/cpt/jobs?start_date=2023-01-15&end_date=2023-01-01"
        )

        assert response.status_code == 422
        data = response.json()
        assert "start_date must be before end_date" in data["error"]

    def test_jobs_with_filter(self, client, monkeypatch):
        """Test jobs endpoint with product filter."""
        mock_response = {
            "data": pd.DataFrame(
                {
                    "uuid": ["test-uuid"],
                    "testName": ["test"],
                    "jobStatus": ["SUCCESS"],
                    "product": ["ocp"],
                }
            ),
            "total": 1,
        }

        async def mock_fetch_data_limited(*args, **kwargs):
            return mock_response

        monkeypatch.setattr(
            "app.api.v1.endpoints.cpt.cptJobs.fetch_data_limited",
            mock_fetch_data_limited,
        )

        # Mock update_filter_product function
        def mock_update_filter_product(filter_str):
            return ["ocp"], {"product": ["ocp"]}

        monkeypatch.setattr(
            "app.api.v1.endpoints.cpt.cptJobs.update_filter_product",
            mock_update_filter_product,
        )

        response = client.get("/api/v1/cpt/jobs?filter=product:ocp")

        assert response.status_code == 200
        data = response.json()
        assert data["total"] == 1

    def test_jobs_empty_results(self, client, monkeypatch):
        """Test jobs endpoint when no data is returned."""
        mock_response = {"data": pd.DataFrame(), "total": 0}

        async def mock_fetch_data_limited(*args, **kwargs):
            return mock_response

        monkeypatch.setattr(
            "app.api.v1.endpoints.cpt.cptJobs.fetch_data_limited",
            mock_fetch_data_limited,
        )

        response = client.get("/api/v1/cpt/jobs")

        assert response.status_code == 200
        data = response.json()
        assert data["total"] == 0
        assert len(data["results"]) == 0

    def test_jobs_with_pagination(self, client, monkeypatch):
        """Test jobs endpoint with pagination parameters."""
        mock_response = {
            "data": pd.DataFrame(
                {
                    "uuid": ["test-uuid"],
                    "testName": ["test"],
                    "jobStatus": ["SUCCESS"],
                    "product": ["ocp"],
                }
            ),
            "total": 1,
        }

        async def mock_fetch_data_limited(*args, **kwargs):
            return mock_response

        monkeypatch.setattr(
            "app.api.v1.endpoints.cpt.cptJobs.fetch_data_limited",
            mock_fetch_data_limited,
        )

        response = client.get("/api/v1/cpt/jobs?size=10&offset=0&totalJobs=100")

        assert response.status_code == 200
        data = response.json()
        assert data["offset"] == 10  # offset + size
        assert data["total"] == 5  # ignore totalJobs when offset > 0

    def test_jobs_with_pagination_total(self, client, monkeypatch):
        """Test jobs endpoint with pagination parameters."""
        mock_response = {
            "data": pd.DataFrame(
                {
                    "uuid": ["test-uuid"],
                    "testName": ["test"],
                    "jobStatus": ["SUCCESS"],
                    "product": ["ocp"],
                }
            ),
            "total": 1,
        }

        async def mock_fetch_data_limited(*args, **kwargs):
            return mock_response

        monkeypatch.setattr(
            "app.api.v1.endpoints.cpt.cptJobs.fetch_data_limited",
            mock_fetch_data_limited,
        )

        response = client.get("/api/v1/cpt/jobs?size=10&offset=10&totalJobs=100")

        assert response.status_code == 200
        data = response.json()
        assert data["offset"] == 20  # offset + size
        assert data["total"] == 100  # totalJobs when offset > 0


class TestFiltersEndpoint:
    """Test the /api/v1/cpt/filters endpoint."""

    def test_filters_success(self, client, monkeypatch):
        """Test successful filters endpoint call."""
        # Mock datetime for default date calculation
        fixed_date = datetime(2023, 1, 15, 10, 0, 0)

        class MockDatetime(datetime):
            @classmethod
            def utcnow(cls):
                return fixed_date

        monkeypatch.setattr("app.api.v1.endpoints.cpt.cptJobs.datetime", MockDatetime)

        # Mock the filter responses
        mock_response = {
            "total": 10,
            "summary": {"success": 8, "failure": 2, "other": 0, "total": 10},
            "data": [
                {"key": "testName", "value": ["test1", "test2"]},
                {"key": "version", "value": ["v1.0", "v1.1"]},
            ],
        }

        async def mock_fetch_data_limited(*args, **kwargs):
            return mock_response | {"product": args[0]}

        monkeypatch.setattr(
            "app.api.v1.endpoints.cpt.cptJobs.fetch_data_limited",
            mock_fetch_data_limited,
        )

        # Mock FILEDS_DISPLAY_NAMES
        mock_display_names = {"testName": "Test Name", "version": "Version"}
        monkeypatch.setattr(
            "app.api.v1.endpoints.cpt.cptJobs.FILEDS_DISPLAY_NAMES", mock_display_names
        )

        response = client.get("/api/v1/cpt/filters")

        assert response.status_code == 200
        # The response is, oddly, searialized JSON as a JSON string: unserialize it
        data = json.loads(response.json())
        assert data["total"] == 50  # 5 products × 10 each
        assert "filterData" in data
        assert "summary" in data
        assert data["startDate"] == "2023-01-10"
        assert data["endDate"] == "2023-01-15"

    def test_filters_pretty_format(self, client, monkeypatch):
        """Test filters endpoint with pretty format."""
        fixed_date = datetime(2023, 1, 15, 10, 0, 0)

        class MockDatetime(datetime):
            @classmethod
            def utcnow(cls):
                return fixed_date

        monkeypatch.setattr("app.api.v1.endpoints.cpt.cptJobs.datetime", MockDatetime)

        mock_response = {
            "product": "ocp",
            "total": 10,
            "summary": {"success": 8, "failure": 2, "other": 0, "total": 10},
            "data": [{"key": "testName", "value": ["test1", "test2"]}],
        }

        async def mock_fetch_data_limited(*args, **kwargs):
            return mock_response

        monkeypatch.setattr(
            "app.api.v1.endpoints.cpt.cptJobs.fetch_data_limited",
            mock_fetch_data_limited,
        )

        mock_display_names = {"testName": "Test Name"}
        monkeypatch.setattr(
            "app.api.v1.endpoints.cpt.cptJobs.FILEDS_DISPLAY_NAMES", mock_display_names
        )

        response = client.get("/api/v1/cpt/filters?pretty=true")

        assert response.status_code == 200
        data = response.json()  # This should work when pretty=True
        assert "filterData" in data

    def test_filters_invalid_date_range(self, client):
        """Test filters endpoint with invalid date range."""
        response = client.get(
            "/api/v1/cpt/filters?start_date=2023-01-15&end_date=2023-01-01"
        )

        assert response.status_code == 422
        data = response.json()
        assert "start_date must be before end_date" in data["detail"]

    def test_filters_with_product_filter(self, client, monkeypatch):
        """Test filters endpoint with product filter."""
        mock_response = {
            "product": "ocp",
            "total": 5,
            "summary": {"success": 3, "failure": 2, "other": 0, "total": 5},
            "data": [{"key": "testName", "value": ["test1"]}],
        }

        async def mock_fetch_data_limited(*args, **kwargs):
            return mock_response

        monkeypatch.setattr(
            "app.api.v1.endpoints.cpt.cptJobs.fetch_data_limited",
            mock_fetch_data_limited,
        )

        def mock_update_filter_product(filter_str):
            return ["ocp"], {"product": ["ocp"]}

        monkeypatch.setattr(
            "app.api.v1.endpoints.cpt.cptJobs.update_filter_product",
            mock_update_filter_product,
        )

        mock_display_names = {"testName": "Test Name"}
        monkeypatch.setattr(
            "app.api.v1.endpoints.cpt.cptJobs.FILEDS_DISPLAY_NAMES", mock_display_names
        )

        response = client.get("/api/v1/cpt/filters?filter=product:ocp")

        assert response.status_code == 200
        data = json.loads(response.json())
        assert data["total"] == 5

    def test_filters_merge_duplicate_keys(self, client, monkeypatch):
        """Test filters endpoint merging duplicate keys correctly."""
        fixed_date = datetime(2023, 1, 15, 10, 0, 0)

        class MockDatetime(datetime):
            @classmethod
            def utcnow(cls):
                return fixed_date

        monkeypatch.setattr("app.api.v1.endpoints.cpt.cptJobs.datetime", MockDatetime)

        # Mock responses that will test the merging logic
        responses = [
            {
                "product": "ocp",
                "total": 5,
                "summary": {"success": 3, "failure": 2, "other": 0, "total": 5},
                "data": [
                    {"key": "testName", "value": ["test1", "test2"]},
                    {"key": "version", "value": [1, 2]},
                ],
            },
            {
                "product": "quay",
                "total": 3,
                "summary": {"success": 2, "failure": 1, "other": 0, "total": 3},
                "data": [
                    {
                        "key": "testName",
                        "value": ["test2", "test3"],
                    },  # Duplicate test2, new test3
                    {"key": "version", "value": [2, 3]},  # Duplicate 2, new 3
                ],
            },
        ]

        call_count = 0

        async def mock_fetch_data_limited(*args, **kwargs):
            nonlocal call_count
            result = responses[call_count % len(responses)]
            call_count += 1
            return result

        monkeypatch.setattr(
            "app.api.v1.endpoints.cpt.cptJobs.fetch_data_limited",
            mock_fetch_data_limited,
        )

        mock_display_names = {"testName": "Test Name", "version": "Version"}
        monkeypatch.setattr(
            "app.api.v1.endpoints.cpt.cptJobs.FILEDS_DISPLAY_NAMES", mock_display_names
        )

        response = client.get("/api/v1/cpt/filters")

        assert response.status_code == 200
        data = json.loads(response.json())

        # Find the merged filter data
        filter_data = {item["key"]: item["value"] for item in data["filterData"]}

        # testName should have unique values: test1, test2, test3
        assert "testName" in filter_data
        test_names = filter_data["testName"]
        assert len(test_names) == 3
        assert "test1" in test_names
        assert "test2" in test_names  # Should not be duplicated
        assert "test3" in test_names

        # version should have unique values: 1, 2, 3
        assert "version" in filter_data
        versions = filter_data["version"]
        assert len(versions) == 3
        assert 1 in versions
        assert 2 in versions  # Should not be duplicated
        assert 3 in versions

    def test_filters_empty_results(self, client, monkeypatch):
        """Test filters endpoint when no data is returned."""
        fixed_date = datetime(2023, 1, 15, 10, 0, 0)

        class MockDatetime(datetime):
            @classmethod
            def utcnow(cls):
                return fixed_date

        monkeypatch.setattr("app.api.v1.endpoints.cpt.cptJobs.datetime", MockDatetime)

        mock_response = {
            "product": "",
            "total": 0,
            "summary": {"success": 0, "failure": 0, "other": 0, "total": 0},
            "data": [],
        }

        async def mock_fetch_data_limited(*args, **kwargs):
            return mock_response

        monkeypatch.setattr(
            "app.api.v1.endpoints.cpt.cptJobs.fetch_data_limited",
            mock_fetch_data_limited,
        )

        response = client.get("/api/v1/cpt/filters")

        assert response.status_code == 200
        data = json.loads(response.json())
        assert data["total"] == 0
        assert len(data["filterData"]) == 0
